##NASM

Почему NASM?

Во первых, он мультиплатформенный, т.е. для портирования программы на разные ОС достаточно только изменить код взаимодействия с системой, а всю программу переписывать не нужно

Во вторых, он, его синтаксис непротиворечив и недвусмысленен, в чем схож с AT&T 

В третьих, он имеет привычный Intel-синтаксис, т.е. программист на MASM или TASM сможет без особых проблем перейти на NASM


###Hello world!
А теперь перейдем к первой программе:

```asm
;Листинг 01 - минимальная программа для Linux
;Приемы оптимизации не применяются для упрощения кода

global _start

_start:

mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, msglen
int 0x80

mov eax, 1
mov ebx, 0
int 0x80

section .data

msg: db "Linux rulez 4ever",0x0A,0
msglen equ $-msg
```

Рассмотрим программу поподробнее:
Знак ';' (точка с запятой) означает комментарий - все что находится правее этого символа ассемблер игнорирует

`global _start` - директива global указывает ассемблеру сделать глобальной (экспортируемой) метку "_start". Подробнее об экспортируемых метках см. ниже

`_start:` - объявление метки с именем "_start". Фактически это означает, что в программе будет определена константа _start, которая будет иметь значение равное адресу, по которому объявлена данная метка

Предыдущие три строчки были директивами ассемблера, т.е. не являлись командами процессора, и не преобразовывались при компиляции в машинный код. Следущие строчки являются именно командами процессора:

`mov eax, 4` - машинная команда MOV копирует данные из второго операнда в первый. В данном случае первый операнд - это регистр EAX (подробнее о регистрах - в следующем уроке). Второй операнд - это константа(определенное в момент компилирования и неизменяемое значение). Результатом выполнения этой команды будет то, что в регистре EAX окажется число 4. Операнды команды разделяются запятой

`mov ebx, 1` - то же самое, но помещается единица в регистр EBX

`mov ecx, msg` - на первый взгляд эта команда отличается от двух предыдущих, но она тоже выполняет перемещение данных, только в данном случае используется константа msg, которая определена ниже и регистр ECX

`mov edx, msglen` - содержимое определенной ниже константы msglen помещается в регистр EDX

`int 0x80` - команда int процессора вызывает т.н. программное прерывание. Грубо говоря - программное прерывание - это команда перехода выполнения программы в определенный операционной системой обработчик прерывания. Всего процессор поддерживает 256 обработчиков для 256 прерываний и операнд этой команды указывает на обработчик какого прерывания нужно передать выполнение программы. 0x80 - 80 в шестнадцатеричной системе счисления (на шестнадцатеричную систему указывают первые два символа: 0x). В случае ОС Linux, прерывание с номером 0x80 является системным вызовом - передачей управления ядру системы с целью выполнения каких-либо действий. В регистре EAX должен находится номер системного вызова, в зависимости от которого ядро системы будет выполнять какие-либо действия. В данном случае мы помещаем в EAX число 4, т.е. указываем ядру выполнить системный вызов номер 4 (write). Этот системный вызов используется для записи данных в файл или на консоль (которая тоже в принципе представлена файлом). В EBX мы поместилидескриптор(идентификатор) консоли - stdout. В ECX и EDX содержатся адрес начала сообщения (адрес первого байта) и длина сообщения в байтах. Т.е этот системный вызов должен выполнить вывод строчки, находящейся по адресу msg, на консоль.

[Список системных выховов](http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html)

`mov eax, 1` - в EAX помещается 1 - номер системного вызова "exit"

`mov ebx, 0` - в EBX помещается 0 - параметр вызова "exit" означает код с которым завершится выполнение программы

`int 0x80` - системный вызов. После системного вызова "exit" выполнение программы завершается

`section .data` Директива ассемблера section определяет следующие данные, как находящиеся в указанном в качестве параметра сегменте. Сегмент .text - сегмент кода, в котором должен находиться исполняемый код программы и чтение из которого запрещено. Сегмент .data - сегмент данных, в котором должны находиться данные программы. Выполнение (передача управления) на сегмент данных запрещена. Поскольку следующие строчки нашей программы - данные, то мы определяем сегмент данных.

`msg: db "Linux rulez 4ever",0x0A,0` - вначале мы определяем метку msg (напоминаю, что метка - текущий адрес), и сразу после нее - строчку, т.е. метка msg будет указывать на первый байт строки. Директива db указывает ассемблеру поместить в данном месте байт данных. Несколько байт могут быть разделены запятой. Если нужно поместить символ, то запись 'X' означает код символа 'X', а форма записи "abcde" эквивалентна 'a', 'b', 'c', 'd', 'e'. Код символа 0x0A означает переход строки, а нулевой байт является концом строки. Поскольку вызов write знает точно, сколько байт нужно выводить, то нулевой байт в конце строки необязателен, но мы его все равно поставим :). Он необходим для программ, взаимодействующих с GLIBC, т.к. функции стандартной библиотеки Си вычисляют длину строки, как расстояние между первым байтом и ближайшим нулевым байтом.

`msglen equ $-msg` - директива equ определяет константу, расположенную слева от директивы и присваивает ей значение, находящееся справа. Символ $ является специальной константой ассемблера, значение которой всегда равно адресу по которому она находится, т.е в данном случае выражение $ - msg как раз будет равно длине строки, т.к. в данном месте программы $ равно адресу следующего за строкой байта. Результат этой директивы - мы определили константу msglen, значение которой равно длине определенной выше строки.

Результат работы ассемблера - это объектный файл. Так как мы компилируем программу под Linux, то нам необходим объектный файл формата ELF (Executable and Linkable Format). Получить его можно следующей командой: 

`nasm -f elf prog01.asm`

Полученный объектный файл необходимо скомпоновать. Такое название это действие получило потому, что с его помощью можно компоновать несколько объектных файлов в один исполняемый. Если в каком-нибудь из объектных файлов существуют экспортируемые функции или переменные, то они доступны всем компонуемым объектным файлам. Существует функция, которая должна быть определена всегда - это точка входа - "_start". С этой функции начинается выполнение программы. 
Компоновка:

`ld -m  elf_i386 prog01.o -o prog01`

Поскольку мы не использователи никаких библиотек, а взаимодействовали напрямую с ядром системы, то при компоновке мы указываем только наш объектный файл.
После выполнения этой команды файл "prog01" будет исполняемым файлом нашей программы.

###Использование системного вызова read
Системный вызов Linux "read" (#3) предназначен для чтения из файла с текущей позиции. Также он может быть использован для чтения данных введенных с клавиатуры (используется файловый дескриптор 2 - stdin).
Ниже приведена программа, которая выведет введенные с клавиатуры символы на экран.

```asm
global _start

_start:

mov eax, 3   ; Вызов #3
mov ebx, 0   ; Дескриптор stdin
mov ecx, buffer   ; Адрес буфера для хранения введенных данных
mov edx, 10   ; Максимальная длина ввода
int 0x80      ; Прерывание - системный вызов

mov eax, 4   ; Вызов #4 (write)
mov ebx, 1   ; Дескриптор stdout

; Системный вызов не изменил содержимое регистров ECX и EDX
; поэтому следующие две строчки не нужны
; mov ecx, buffer ; Адрес строки для вывода
; mov edx, 10     ; Длина выводимых данных

int 0x80   ;Системный вызов

xor eax, eax   ; Обнуление регистра eax
inc eax        ; Инкремент - увеличение на единицу
int 0x80       ; Системный вызов

section .bss   ; Начало сегмента данных
buffer: resb 10   
```

Директива ассемблера resb 10 предназначена для резервирования указанного количества байт. Содержимое этих байт не определено, но поскольку они находятся в сегменте данных, то их содержимое будет равно нулю.

Команда xor операнд1, операнд2 на самом деле выполняет логическую операцию "исключающее или" над каждым битом операндов, т.е. какой-либо бит результата равен 1 только в том случае, если значения соотвествующих битов операндов различны. Эта операция чаще всего используется для обнуления регистров - очевидно, что если операнды равны, то все биты результата будут равны 0. Команды inc операнд увеличивает содержимое операнда на единицу. Для занесения единицы в регистр лучше использовать не mov reg, 1, а последовательность команд:

xor reg, reg

inc reg

поскольку команда mov в четырехбайтный регистр занимает пять байт, а указанная выше последовательность - только 3 байта. Аналогичным образом для занесения в регистр двойки лучше воспользоваться командой xor и дважды применить команду inc - это займет четыре байта


###Сложение числа из ввода

Четыре самые распространенные секции это:

1. .text — скомпилированный машинный код

2. .data — глобальные и статические переменные;

3. .rodata — аналог .data для неизменяемых данных;

4. .bss — глобальные и статические переменные, которые при старте содержат нулевое значение. Секция bss используется как место для хранения глобальных переменных. Вы можете выделить адресное пространство для секции bss, но Вы не можете указать, какие данные будут загружены в нее до исполнения программы. Когда пpогpамма начинает pаботy, секция bss заполнена нулями.

RESB, RESW, RESD, RESQ и REST разработаны для использования в BSS-секции модуля: они объявляют не инициализированное пространство для хранения данных. Каждая принимает один операнд, являющийся числом резервируемых байт, слов, двойных слов и т.д. 

Например:

```asm

     buffer:   resb 64                ; резервирование 64 байт 
     wordvar:  resw 1                 ; резервирование слова 
     realarray resq 10                ; массив из 10 чисел с плавающей точкой
```

Вводим одну цифру и прибавляем 1, после выводим

```asm
section .bss
    buf:   resb    1
    res:   resb    1
section .text
    global  _start
_start:             ; you made the label _start global, 
                    ; but you forgot to add the label.
_read:
    mov     eax, 3      ; sys_read
    mov     ebx, 0      ; stdin
    mov     ecx, buf    ; buffer (memory address, where read should save 1 byte)
    mov     edx, 1      ; read byte count
    int     80h

_adding:   
    mov     cl, [buf]   ; copy 1 byte (the ASCII-char) from address buf into cl
    sub     cl, '0'     ; same as "sub cl, 30h"; changes ASCII number into binary number. (This is optional)
    add     cl, 1       ; it will not work, when the result is >9! 
                        ; Because then you get 2 digits
    add     cl, '0'     ; convert binary number back to ascii-char. 
                        ; (This is optional)
    mov     [res], cl   ; you could use buf instead of res, too.

_write:    
    mov     eax,    4           ; sys_write
    mov     ebx,    1           ; stdout
    mov     ecx,    res         ; buffer
    mov     edx,    1           ; write byte count
    int     80h

_exit:
    mov     eax,    1           ; exit
    mov     ebx,    0           ; exit status
    int     80h
```

###Считывание целого числа и печать

Данная программа имеет простую логику: считывает целое число и выводит его. Но в коде вместо описания функции scan_int стоит "заглушка", которая всегда возвращает 133.


```asm
section .bss
    buffer resb 20

section .text
global _start
_start:
    call scan_int   ; читать int  из stdin в регистр eax
    push eax        ; поместить eax в стек — это будет 
                    ; аргументом для следующей функции

    call print_int  ; напечатать int, который находится в вершине стека
                    ; в стандартный поток вывода
                    ; "call func" эквивалентно 
                    ;    push <адрес_следующей_инструкции>;
                    ;    jmp func

    mov eax, 1      ; Эти три строчки эквиваленты exit(0)
    mov ebx, 0      ;
    int 0x80        ;

scan_int:           ; эта функция должна читать int из stdin,
    mov eax, 133    ; но пока она не реализована и просто 
    ret             ; возвращает число 133

print_int:          ; функция печати целого числа в stdout
                    ; аргумент (4-байтовое целое число)
                    ; находится в вершине стека
    ; ebp содержит адрес начала stack frame
    ; esp содержит адрес вершины стека
    ; esp < ebp, то есть вершина имеет меньший адрес
    ; в начале по адресам (ebp-4, ebp-3, ebp -2, ebp -1) лежат
    ; четыре байта целого числа, которое нам передали 
    ; в качестве аргумента

    push ebp        ; поместим в стек адрес начала стека 
                    ; этот push автоматически делает esp -= 4 
    mov ebp, esp    ; теперь ebp равно esp 
                   
                     ; аргумеенты находятся по адресу ebp + 8
    mov ecx, [ebp+8] ; значение переданного нам целого числа поместим в ecx

    xor edx, edx     ; обнулим edx
    mov esi, 10      ; на 10 мы будем делить.

    mov edi, 18      ; символы-цифры нашего числа мы будем помещать
                     ; по адресам buffer + 17, buffer+16, buffer+15, ...

    mov byte [buffer + 18], 0xA ; 19-й и 20-й символы — это перенос строчки
    mov byte [buffer + 19], 0   ; и символ конца строки

.loop:
    mov eax, ecx   ;
    xor edx, edx   ; данные четыре строки дают
    div esi        ;   ecx = ecx / 10 
    mov ecx, eax   ;


    add edx, '0'  ; '0' ассемблером интерпретируется как ASCII код символа '0'
    dec edi
    mov byte [buffer+edi], dl
    cmp ecx, 0
    jne .loop

    mov eax, 4        ; эквивалентно write( 1, buffer + edi, 19 - edi )
    mov ebx, 1
    mov ecx, buffer   ; можно короче — lea ecx, [buffer+edi]
    add ecx, edi
    mov edx, 19
    sub edx, edi
    int 0x80

    leave       ; эквивалентно  mov esp, ebp
                ;               pop ebp 
    ret         ; эквивалентно  pop IP 
                ;               
```

Считывание целого положительного числа на Си без использования scanf

```c
#include <unistd.h>
char buffer[20];
int scan_int() {
   int a = 0;
   do {
       int c;
       int ret = read( 2, buffer, 1 );
       c = buffer[0];
       if( ret > 0 && c != '\n' ) {
           a *= 10; 
           a += c - '0'; 
       } else {
           break;
       }
   } while(1);
   return a;
}

int print_int(int a) { 
   int c;
   int i = 20;
   buffer[--i] = 0;
   buffer[--i] = '\n';
   
   do {
       c = a % 10;
       a /= 10;
       c += '0';
       buffer[--i] = c;
   } while( a );
   write( 1, buffer + i, 20 - i );
   return a;
}
int main() {
    int a = scan_int();
    print_int( a );
}
```

####Задание
Напишите правильную реализацию функции scan_int. Логика этой функции должна быть такой, как в приведённой ниже программе на Си.
